/**
     * 1、统计[1..6]出现的次数（注意不要重复统计A、B）
     * 2、如果num出现次数大于len的先求A中的次数count得到需要旋转len-count个
     * 2.1、得出B中num出现次数为count的得到需要旋转len-count个
     * 2.2、获取两个len-count的最小值
     *
     * alter : int min = Integer.MIN_VALUE;
     * @param A
     * @param B
     * @return
     */
    public int minDominoRotations(int[] A, int[] B) {
        int[] pool = new int[7];
        if (A == null || B == null || A.length != B.length)
            return -1;
        int len = A.length;
        for (int i = 0; i < len; i++) {
            pool[A[i]]++;
            if (A[i] != B[i])
                pool[B[i]]++;
        }

        int min = Integer.MAX_VALUE;
        for (int i = 1; i < 7; i++) {
            if (pool[i] >= len) {
                int count = 0;
                for (int j = 0; j < len; j++) {
                    if (i == A[j])
                        count++;
                }

                min = Math.min(min, len - count);
                count = 0;
                for (int j = 0; j < len; j++) {
                    if (i == B[j])
                        count++;
                }

                min = Math.min(min, len - count);
            }
        }
        return min == Integer.MAX_VALUE ? -1 : min;
    }
