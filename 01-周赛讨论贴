第136场周赛：https://leetcode-cn.com/discuss/forum.php?mod=viewthread&tid=906&extra=page%3D1
第一题，从原点按照指令走4遍，没有回到原点即为True；
第二题，回溯；
第三题，动态规划，dp[i] = max(dp[i], dp[i - j] + max(A[i - j + 1:i + 1]) * j for j in [1, K])；
第四题，后缀数组
——————————————————————————————————————————————————————————————————————————————————————————————
第137场周赛：https://leetcode-cn.com/discuss/forum.php?mod=viewthread&tid=926&extra=page%3D1
第一题，根据题意，排序以后取最大的两个，相减获取结果如果不为0，则把差值二分插入原来的有序数组里，直到
数组里的元素个数小于2，如果数组空则返回0，如果数组只剩一个元素，则返回这个元素；
第二题，用栈结构，类似于括号匹配，与栈顶元素不同则入栈，与栈顶元素相同则栈顶元素弹出，最后栈里剩下的所
有字符连接构成的字符串即为结果；
第三题，把每个单词看成一个结点，如果word1是word2的前身，则有一条边从word1指向word2，所以整个单词集构
成一个有向无环图，用dfs求这个有向无环图的最长路径，需要保存中间结果避免重复搜索。还有一个巧妙的解法，
由于单词长度比较小，将单词按照长度从小到大排序，然后构建字典f，顺序求 f[w] = max(f[w], 
f[w[:i] + w[i+1:]] + 1) for i in range(len(w)) 并更新答案；
第四题，相当于把每个石头前面填上正号或者负号（不能全为正或全为负），问题可以转化为，给定一个数组，
将这个数组分成两部分，使这两部分和的差最小，用动态规划解题。
————————————————————————————————————————————————————————————————————————————————————————————————
